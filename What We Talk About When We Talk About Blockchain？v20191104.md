
# What We Talk About When We Talk About Blockchain？

![](WhatWeTalkAboutWhenWeTalkAboutLove.jpg)

Xubin Cao

SWUFE Chengdu

2019.11.4


## 第一部分：问题的提出和问题阶梯

请每位同学们写下不少于5个有关区块链（比特币）的问题（5分钟）

### 展示同学们的问题（5分钟）

### 与区块链（比特币）有关的一些词 

Blockchain / block

ECC /HASH /SHA-256

Bitcoin /POW /Mine / transaction / ledger

Satoshi Nakamoto

2100万

50/25/12.5

genesis block

BTC/BTH

2017.08.01 00:31:20

软分叉/应分叉

比特币交易所 

### 问题的阶梯1

#### 常见问题：（当面对未知的时候，首先是了解这是一个关于什么的问题？）
1. what？什么是区块链？
2. who？ 区块链什么时间出现的？
3. when？区块链是谁发明（发现）的？
4. why？区块链为什么会出现？
5. how？区块链的原理？它与哪些技术相关？
6. ……

### 问题的阶梯2

#### 进一步问题：（问题与什么相关，值得学习吗）

1. 区块链技术是先进的技术吗？为什么说区块链技术是未来互联网的具有颠覆性的技术革命？这种说法是正确的吗？
2. 区块链就是比特币吗？
3. 还有什么其他的区块链技术？
4. 区块链与什么行业可以结合，从而推动行业的变革？
5. 区块链技术已经有了哪些应用？
6. ……

### 问题的阶梯3

#### 再进一步问题：（问题代表的价值和本质又是什么？| 如果学习它，需要付出多大的代价？）
1. 区块链的本质特征是什么？
2. 区块链的有什么特有的技术或价值？
3. 区块链是一个技术问题还是思想模式（思维范式、研究范式）问题？
4. 区块链的（技术）思想将推动哪些领域的科学技术发展？
5. 区块链技术的生命周期（趋势）如何？
6. 如何学习它……


### 问题的阶梯4

扩展问题：

1.  如何保证比特币的产出速度大致恒定？

2. 为何比特币总量上限是2100万枚？
3. 什么是比特币交易所？
  - 3.1 交易所的出现，不是又变回中心化了，违背了比特币系统创立的初衷？
  - 3.2 比特币存在交易所中安全吗？
4. 怎样购买比特币？
5. 中本聪到底是谁？
 
6. 51%攻击是怎么一回事？（公开的漏洞）
7. 比特币系统的核心代码现在是谁在维护？

8. 什么是比特币系统的硬分叉？
  - 8.1 分叉的产生？
  - 8.2 软分叉？
    - 代码有bug？
    - 节点升级的时间先后不一致？
  - 8.3 硬分叉？
    - 区块容量问题（定时炸弹）：1M=0.25KB*4000
    - 扩容方案
      - 争论不休
      - “香港共识”（2016.2）
      - “纽约共识”（2017.5）
    - BCH（BCC）：Bitcoin Cash
      - step1: BCH/2017.08.01 00:31:20 UTC
      - step2: NO （1 MB-->2 MB）
9. 哪个国家挖的比特币最多？
10. 什么是僵尸比特币？有多少？
11. 谁有最多的比特币？
12. 哪些国家承认比特币是合法的？（德国是第一个）
13. 哪些国家承认比特币是货币？（澳大利亚和瑞典）
14. 哪些国家承认比特币支付是合法的？（法国、日本）
15. 比特币ATM（2013年11月加拿大温哥华）有多少？ （>2000台）
16. 比特币的未来？
17. ……

## 寻找问题的答案
 
 * 我们在哪里寻找答案？
 * 我们如何寻找答案？
 * 我们能找到哪些类型的答案？
 * 哪些问题是没有直接的答案的？

### 寻找问题的答案1

* 通过互联网查找答案
* 通过图书、论文、公开的资料查找答案
* 通过讨论/争论/群体智慧
* 通过实验/实战等动手来寻找答案
* 通过冥想/思维实验/……

### 看看搜索的结果



```python
from IPython.display import IFrame

IFrame(src='http://baidu.com', width=1000, height=800)
```





        <iframe
            width="1000"
            height="800"
            src="http://baidu.com"
            frameborder="0"
            allowfullscreen
        ></iframe>
        



* 区块链是什么？

> 区块链（英语：blockchain[1][2][3]或block chain[4][5]）是借由密码学[1][6]串接并保护内容的串连交易记录（又称区块）。每一个区块包含了前一个区块的加密散列、相应时间戳记以及交易数据（通常用默克尔树算法计算的散列值表示）[7]，这样的设计使得区块内容具有难以篡改的特性。用区块链所串接的分布式账本能让两方有效纪录交易，且可永久查验此交易。
中本聪在2008年，于《比特币白皮书》[8]中提出“区块链”概念，并在2009年创立了比特币网络，开发出第一个区块，即“创世区块”。[9]
> [wiki百科](https://zh.wikipedia.org/wiki/区块链)

> 区块链是分布式数据存储、点对点传输、共识机制、加密算法等计算机技术的新型应用模式。 [1]
区块链（Blockchain），是比特币的一个重要概念，它本质上是一个去中心化的数据库，同时作为比特币的底层技术，是一串使用密码学方法相关联产生的数据块，每一个数据块中包含了一批次比特币网络交易的信息，用于验证其信息的有效性（防伪）和生成下一个区块。 [2]
比特币白皮书英文原版 [3]  其实并未出现 blockchain 一词，而是使用的 chain of blocks。最早的比特币白皮书中文翻译版 [4]  中，将 chain of blocks 翻译成了区块链。这是“区块链”这一中文词最早的出现时间。
> [baidu百科](https://baike.baidu.com/item/区块链/13465666?fr=aladdin)

> 李鸣认为，从技术视角来看，区块链只是一个技术组件，跟AI，大数据等其他新一代信息技术共同完成它特定的功能——最大化数据的价值。而最终，存证、确权、交易/交换、金融衍生品、溯源等五个方面可以涵盖大部分区块链的应用。
> [工信部李鸣：区块链是一种技术组件，核心作用是最大化数据价值](https://www.huoxing24.com/newsdetail/20181114154913559492.html)

> 工信部指导发布的《中国区块链技术和应用发展白皮书2016》这样解释：广义来讲，区块链技术是利用块链式数据结构来验证与存储数据、利用分布式节点共识算法来生成和更新数据、利用密码学的方式保证数据传输和访问的安全、利用由自动化脚本代码组成的智能合约来编程和操作数据的一种全新的分布式基础架构与计算范式。

>　　交通银行金融研究中心高级研究员何飞进行了通俗解释：“简单地说，区块链就是一种去中心化的分布式账本数据库。”去中心化，即与传统中心化的方式不同，这里是没有中心，或者说人人都是中心；分布式账本数据库，意味着记载方式不只是将账本数据存储在每个节点，而且每个节点会同步共享复制整个账本的数据。同时，区块链还具有去中介化、信息透明等特点。
---

>　　“区块链技术本质上是一种数据库技术，具体讲就是一种账本技术。账本记录一个或多个账户资产变动、交易情况，其实是一种结构最为简单的数据库，我们平常在小本本上记的流水账、银行发过来的对账单，都是典型的账本。”腾讯金融科技智库首席研究员王钧说，安全是区块链技术的一大特点，主要体现在两方面：一是分布式的存储架构，节点越多，数据存储的安全性越高；二是其防篡改和去中心化的巧妙设计，任何人都很难不按规则修改数据。
> [三问区块链：是什么？有什么用？会成新风口吗？](http://www.xinhuanet.com/finance/2018-02/26/c_1122452794.htm)

### 思考：我们搜索一些区块链企业的产品，我们能看懂多少？ 
（如果有人问你这个产品是否值得投资或者购买？你能提供什么意见或者建议？）

---
# 第二部分 当我们谈论区块链时我们在谈论什么？
---

我们今天讲授的重点：

希望同学去通过对区块链相关资料的阅读，了解其核心特点、技术特色、本质等，如何做到呢？

**以比特币系统为例来介绍区块链**

### 第一个话题：去中心化（理念）

---

什么是去中心化？如何去理解去中心化，这种理念的实质是什么？为什么会产生？

### 中心化 vs 去中心化


![blockchain-cash-bitcoin.png](attachment:blockchain-cash-bitcoin.png)

#### 中心化

---

* 我们购买爱奇艺、腾讯的会员看电影（它可以限制你的访问速度，强迫看广告）
* 我们的QQ，需要中心服务器
* 我们的微信，有中心服务器，它可以限制你可以建立多少群，每个群多少人，每个人可以看到什么样的广告 ；
* 我们的支付宝，需要服务器；我们的淘宝，百度，微博，这些都可以理解为中心化。

（地位不平等，存在特权）

#### 去中心化

---

* p2p （地位平等？不存在特权）

* p2p(peer to peer) vs (people to people)
* BT下载（电驴emule\迅雷……）


说点与金融相关的，比如说我们的银行卡


you-银行卡 -- 开户银行（支付银行-清单银行-开户银行）--央行
you-支付宝 -- 银联（网联）--开户银行 --央行 （如果是国际支付，更加复杂）

层级式的，不同的环节，权力、地位是不同的，不平等的。
* 谁最有权力？
* 谁可以发行货币？
* 如果货币增发100倍，我们的钱会怎样？

### 思考：中心化 和 去中心化
* 哪种模式更有效？
* 更稳定？
* 更容易维护？
* 总体社会成本更低？
* ……

#### 比特币的如何设计的？
1. 货币发行不是由某个机构说了算，而是公开一套算法，每算出一个符合要求的数字，就相当于挖了若干的比特币（总量控制，按设计规则递减）谁都可以去算（公平性），谁也无法作弊（很难而已）；
2. 比特币的交易信息不是记在某一台服务器上，而是所有参与这个 **“游戏”** 的玩家电脑上人手一份，同步记录，这种交易记录在理论上 **几乎是无法篡改的**。

---

比特币--> “去中心化账本”

比特币与之前的P2P都是去中心化，有什么不同呢？

比特币多了一个东西，“账本” -->

除了参与主体的平等，还增加了一个游戏 **规则** 的平等


## 话题二： 账本的问题

---

### 网络上记账有多难？

---

1. 如何确保信息是完整的？
2. 如何确保信息是真实的？
3. 如何确保账户同步？
4. 如何防止账户双花？


### 1. 如何确保信息是完整的？

（信息安全技术的问题）

信息的完整性是指： 信息在使用、传输、存储过程中，信息不被篡改、丢失、缺损等。此外还包括一层意思是说处理信息的方法的正确性。


如何保证一段信息是完整的，没有被篡改呢？

一字一句的校对？
有没有什么好一点的方法，一眼就能知道，这个信息是完整的，没有被篡改过呢？


**数字指纹（数字签名、哈希值、Hash）**



#### 1.1 二进制和编码问题（所有的都是0和1的问题）

---


计算机上任何信息，按照国际的编码规则，最终都是以0和1来存储的，这就是二进制。

国际上有很多的文字编码，ASCII/Unicode/GBK/Big5/……

[什么是字符编码？](https://www.cnblogs.com/yuguangchuan/p/4310952.html)

      计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。最早的计算机在设计时采用8个比特（bit）作为一个字节（byte），所以，一个字节能表示的最大的整数就是255（二进制11111111=十进制255），如果要表示更大的整数，就必须用更多的字节。比如两个字节可以表示的最大整数是65535，4个字节可以表示的最大整数是4294967295。
      
* [UTF-8在线编码转换](http://tool.chinaz.com/Tools/UTF-8.aspx)
* [在线编码转换](http://tool.oschina.net/encode)
* [进制在线转换](http://tool.oschina.net/hexconvert/)


由于计算机是外国人先发明出来，最初的文字符号编码是ASCII编码，后来，各个国家发现自己的语言文字无法用ASCII编码来解决，开始建立相应的编码规则来处理这个问题，后来，随着国际交流的需要，这个问题变成了全球的问题，出现了Unicode编码，这种编码基本上解决了这样的世界难题。其中，UTF-8编码用的最为广泛。

（这样的问题，之前还发生过一次，是哪一次？千年虫的问题，之前的年的存储用的是2位，到了2000年，发现有问题了，结果全世界用了很多钱来解决这个问题，现在的做法是设置为4位，会不会发生未来的万年虫的问题？ ；-））


**ASCII编码：**

　　由于计算机是美国人发明的，因此，最早只有127个字母被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为ASCII编码，比如大写字母 A 的编码是65，小写字母 z 的编码是122。

　　但是要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了GB2312编码，用来把中文编进去。

　　全世界有上百种语言，日本把日文编到Shift_JIS里，韩国把韩文编到Euc-kr里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。

---

**Unicode编码：**

　　因此，Unicode应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。Unicode标准也在不断发展，但最常用的是用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。现代操作系统和大多数编程语言都直接支持Unicode。

**字符的编码**


 A的ASCII编码是：二进制：``` 0100 0001``` ；十进制：```65```

```bash

西南财经大学
 
--> unicode ： \u897f\u5357\u8d22\u7ecf\u5927\u5b66  
--> UFT-8: &#x897F;&#x5357;&#x8D22;&#x7ECF;&#x5927;&#x5B66;
--> 10进制：&#35199;&#21335;&#36130;&#32463;&#22823;&#23398;
--> 2进制： 1000100101111111/101001101010111/1000110100100010

```

```bash

曹旭斌支付100元给陈春林：
--> Unicode:&#26361;&#26093;&#25996;&#25903;&#20184;&#49;&#48;&#48;&#20803;&#32473;&#38472;&#26149;&#26519;

```

我们所说的加密方式，都是对二进制编码的格式进行加密的，对应到Python中，则是我们的Bytes。


```python
print("ABC".encode())
print("中国".encode())
```

    b'ABC'
    b'\xe4\xb8\xad\xe5\x9b\xbd'



```python
import binascii

"西南财经大学".encode("UTF-8")

```




    b'\xe8\xa5\xbf\xe5\x8d\x97\xe8\xb4\xa2\xe7\xbb\x8f\xe5\xa4\xa7\xe5\xad\xa6'




```python
b'\xe8\xa5\xbf\xe5\x8d\x97\xe8\xb4\xa2\xe7\xbb\x8f\xe5\xa4\xa7\xe5\xad\xa6'.decode()
```




    '西南财经大学'




```python
binascii.b2a_hex("西南财经大学".encode())
```




    b'e8a5bfe58d97e8b4a2e7bb8fe5a4a7e5ada6'




```python
binascii.a2b_hex(b'e8a5bfe58d97e8b4a2e7bb8fe5a4a7e5ada6')
```




    b'\xe8\xa5\xbf\xe5\x8d\x97\xe8\xb4\xa2\xe7\xbb\x8f\xe5\xa4\xa7\xe5\xad\xa6'




```python
binascii.a2b_hex(b'e8a5bfe58d97e8b4a2e7bb8fe5a4a7e5ada6').decode()
```




    '西南财经大学'



明白了这个常识，我们就知道任何我们在计算机上处理的信息最后均会通过这样的编码规则转换为2进制的数字，0和1

但这个0和1组成的“数字串”对于人类来说，的确是无法阅读的。

#### 1.2 SHA-256数字指纹：

[在线加密解密](http://tool.oschina.net/encrypt?type=2)


```
曹旭斌支付100元给陈春林：
9432db72f41431ab9eb59e5523af15e3076a5aafaf85b86119e158082cd83e37
曹旭斌支付101元给陈春林
ecbacce087724fc1a92f4c3dd2035058d00d321a26c43d284b82777b87b11ba4

2019年3月25日曹旭斌支付100元给陈春林：
352b68569d48da009158119aa0806f4f40340e6b6d9791253aa7df7875a27e06
2019年3月25日曹旭斌在成都因为购买Apple手机支付100元给陈春林
5a0a6e6b7066af33713ce5c49a6f0c7d467baf97d1c111800c3bf3de3853a72e
101101000001010011011100110101101110000011001101011000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000

```
从上面的结果可以看到，哪怕改动一个字，指纹也差别很大，无法被反向破译


```python
import hashlib

def hash_sha256(input):
    sha256obj = hashlib.sha256()
    sha256obj.update(input.encode("UTF-8"))

    return sha256obj.hexdigest()

message = input("message: ")

print("hash_SHA256: "+hash_sha256(message))

```

    message: 有了“指纹”，就可以来解决了记账信息完整性的问题。 我们可以规定： 任何发送信心的一方，比如同时发出原始信息的指纹。 收到信息的一方，就可以用公开的SHA-256算法把原始信息再算一遍，得到一个指纹， 比较这两个指纹是不是一样的？如果一致，则可以认为数据没有被篡改或者损失；如果不一致，可能是传输中出错了，或者数据被篡改了。 思考： 1：有没有一种可能，数据被篡改了，同时传输中也出现了传输错误，最后的错误信息得到的指纹竟然与原始指纹一样呢？最后的结果负负得正？ 2: 有没有一种可能，数据被黑客截获了，把原始信息改了，重新生成一个“原始”指纹发给你？
    hash_SHA256: b201dec59eb3876bd0b83ab472b332aa131fc8623f3dbb30740ffc58686205f0


有了“指纹”，就可以来解决了记账信息完整性的问题。

我们可以规定：
1. 任何发送信心的一方，比如同时发出原始信息的指纹。

2. 收到信息的一方，就可以用公开的SHA-256算法把原始信息再算一遍，得到一个指纹，

3. 比较这两个指纹是不是一样的？如果一致，则可以认为数据没有被篡改或者损失；如果不一致，可能是传输中出错了，或者数据被篡改了。


#### 思考：

1：有没有一种可能，数据被篡改了，同时传输中也出现了传输错误，最后的错误信息得到的指纹竟然与原始指纹一样呢？最后的结果负负得正？

2: 有没有一种可能，数据被黑客截获了，把原始信息改了，重新生成一个“原始”指纹发给你？  


### 2. 数据的真实性（我应该相信谁？）
---

解决办法：对数字指纹加密

**对称加密：**

比如密码本，我们都用同一种加解密的方法。加解密是一个互逆的求解过程。

---

如果我们要让网上每一个信息接受者都能够解开密文知道原始信息，又要让黑客们即使拿到密文也只能干瞪眼，无法篡改密文？怎么办？

**非对称加密**

```
原始信息：269
我用了一个加密方法，269--> 24479
我告诉大家：我的解密密钥是11，就是说用24479*11，结果的最后三位数就是原始信息。

24479*11=269269，最后三位269
```


怎么做到的？
很简单，
```
原始信息*91=密文
```

这种公钥（解密）和私钥（加密）采用不同密码（方式）的算法就是一种非对称加密，简单的说，就是知道了原文，密文，公钥，也无法（很难）知道私钥。  你可能解密，但无法加密，也就无法修改密文。

这种算法就是ECC算法（椭圆曲线算法）
1985年： 美国人（Neal Kobolitz）+Victor Miller 分别独立提出来的。
椭圆加密算法（ECC）是一种公钥加密体制，最初由Koblitz和Miller两人于1985年提出，其数学基础是利用椭圆曲线上的有理点构成Abel加法群上椭圆离散对数的计算困难性。公钥密码体制根据其所依据的难题一般分为三类：大素数分解问题类、离散对数问题类、椭圆曲线类。有时也把椭圆曲线类归为离散对数类。（https://baike.baidu.com/item/椭圆加密算法/10305582?fr=aladdin）
https://blog.csdn.net/sitebus/article/details/82835492


ECC的应用（比特币）



ECC被广泛认为是在给定密钥长度的情况下，最强大的非对称算法，因此在对带宽要求十分紧的连接中会十分有用。
* 安全性高
有研究表示160位的椭圆密钥与1024位的RSA密钥安全性相同。
* 处理速度快
在私钥的加密解密速度上，ecc算法比RSA、DSA速度更快。
* 存储空间占用小。
* 带宽要求低

>    第六届国际密码学会议对应用于公钥密码系统的加密算法推荐了两种：基于大整数因子分解问题（IFP）的RSA算法和基于椭圆曲线上离散对数计算问题（ECDLP）的ECC算法。RSA算法的特点之一是数学原理简单、在工程应用中比较易于实现，但它的单位安全强度相对较低。目前用国际上公认的对于RSA算法最有效的攻击方法--一般数域筛(NFS)方法去破译和攻击RSA算法，它的破译或求解难度是亚指数级的。ECC算法的数学理论非常深奥和复杂，在工程应用中比较难于实现，但它的单位安全强度相对较高。用国际上公认的对于ECC算法最有效的攻击方法--Pollard rho方法去破译和攻击ECC算法，它的破译或求解难度基本上是指数级的。正是由于RSA算法和ECC算法这一明显不同，使得ECC算法的单位安全强度高于RSA算法，也就是说，要达到同样的安全强度，ECC算法所需的密钥长度远比RSA算法低。这就有效地解决了为了提高安全强度必须增加密钥长度所带来的工程实现难度的问题

>    美国国家标准与技术局和ANSI X9已经设定了最小密钥长度的要求，RSA和DSA是1024位，ECC是160位，相应的对称分组密码的密钥长度是80位。NIST已经公布了一列推荐的椭圆曲线用来保护5个不同的对称密钥大小（80, 112, 128, 192, 256）。一般而言，二进制域上的ECC需要的非对称密钥的大小是相应的对称密钥大小的两倍。

>    在2005年2月16日，NSA宣布决定采用椭圆曲线密码的战略作为美国政府标准的一部分，用来保护敏感但不保密的信息。NSA推荐了一组被称为Suit B的算法，包括用来密钥交换的Menezes-Qu-Vanstone椭圆曲线和Diffie-Hellman椭圆曲线，用来数字签名的椭圆曲线数字签名算法。这一组中也包括AES和SHA。

### 现在：
**SHA-256+ECC就可以确保账户的完整性和真实性了。**


![blockchain-public-crypto.png](attachment:blockchain-public-crypto.png)

####  信息发布：

原始信息：曹旭斌支付100元给陈春林
1. 利用SHA-256，生成数字指纹


2. 随机生成一个私钥，他的 **格式** 和指纹是完全一样的

3. 利用ECC将第一步得到的数字指纹通过第二步得到的私钥加密，得到密文：

4. 根据私钥生成一个公钥：

5. 将原文、密文、公钥广播到整个比特币网络中

---

### 信息接受：

1. 接收方利用ECC将密文通过公钥解密，得到指纹1
2. 利用SHA将原文生成数字指纹，得到指纹2
3. 比对指纹1和指纹2是否一致？
4. 如果指纹一致，则认为信息完整真实，是合法交易，添加到账本中；如果不一致，舍弃这条信息。

---

**一个私钥几乎可以生成无数个不同的对应公钥，谁掌握了私钥，谁就是账号的主人。**
**私钥是动用比特币的唯一凭证**

### 区块链的登场

比特币网络中只有一个 **唯一认可** 的账本，（任何电脑接入网络时，首先需要同步这个账本，才能写入新的信息）

这个账本设计为一个个的信息包首尾相连的长链，每一个信息包就是一个“区块”，每一个区块都有一个编号（height：1，2，3……）

这个看起来简单清晰的规则，实现起来其实是很繁琐的，几乎复杂到不可能同时完成两次。（即便同时完成了两次，还有一条规则等着，哪一条是合法的，哪一条非法）

### 3. 如何同步账本？

1. 不可能所有的电脑都开机，且都开着比特币客户端，等着接受信息
2. 网络速度的问题，总有先后
3. 总有记录不完整不同步的

到底以谁的为准？

先看看区块链如何运行的：（运行规则）

---

![blockchain-from-blocks.png](attachment:blockchain-from-blocks.png)




```python
import math

x = pow(2,72)
print("2的72次方等于："+str(x))
print("2的72次方 有多少位数：" + str(len(str(x))))
```

    2的72次方等于：4722366482869645213696
    2的72次方 有多少位数：22


第一个区块：genesis block（创世纪区块）

1. 前一个区块的数字指纹+固定信息+收到的交易记录+一个随机数（nonce）
2. 这个新区块的数字指纹（一个256位的二进制数）的前72位必须全部为0

每一次新区块的产生都要从头来过，再算一次。

3. 谁先算出来，就获得记账的权力，可以给账本增加一个区块。

因为产生一个区块大约需要10分钟，这个时间用来干什么？ 让大家的电脑可以方便的同步账本。

下面我们用代码简单模拟一下一个区块链的产生。


```python
import random
import hashlib
import time

'''
---------------------
[  index            ]
---------------------
[  previous hash    ]
---------------------
[  timestamp        ]
---------------------
[  data             ]
---------------------
[  hash             ]
---------------------
[  nonce            ]
---------------------
'''

def hash_sha256(input):
    sha256obj = hashlib.sha256()
    sha256obj.update(input.encode("UTF-8"))

    return sha256obj.hexdigest()


def is_valid_hash_diffculty(hash, difficulty):
    for i in range(0, difficulty):
        if hash[i] != '0':
            return False

    return True


def calculate(index, previous_hash, timestamp, transaction, difficulty):
    hash = ""
    nonce = 0
    while True:
        data = str(index) + previous_hash + timestamp + transaction + str(nonce)
        hash = hash_sha256(data)
        if is_valid_hash_diffculty(hash, difficulty):
            return hash, nonce

        nonce += 1


def print_blockchain(index, previous_hash, timestamp, transaction, hash, nonce):
    print("index:" + str(index))
    print("previous_hash:" + previous_hash)
    print("timestamp:" + timestamp)
    print("transaction:" + transaction)
    print("hash:" + hash)
    print("nonce:" + str(nonce))


if __name__ == "__main__":

    datas = ["曹旭斌支付1000000元给陈春林。",
            "陈春林支付100元给CFA2019。",
            "道富集团捐赠10000元给CFA2019。"]

    previous_hash = ""

    now = time.time()

    for index in range(0, len(datas)):
         data = datas[index]
         timestamp = time.strftime('%Y-%m-%d %H:%M:%S',time.localtime(now))
         hash, nonce = calculate(index, previous_hash, timestamp, data, 4 + index)
         print_blockchain(index, previous_hash, timestamp, data, hash, nonce)
         previous_hash = hash

         print("use time:" + str((time.time() - now) * 1000) + "ms")
         print("----------")

         now = time.time()
```

    index:0
    previous_hash:
    timestamp:2019-11-06 20:36:52
    transaction:曹旭斌支付1000000元给陈春林。
    hash:0000ba3a1501d052ebc16e73c1b51533c04d2041aa10ab7c7b126594edd22cde
    nonce:5910
    use time:20.080089569091797ms
    ----------
    index:1
    previous_hash:0000ba3a1501d052ebc16e73c1b51533c04d2041aa10ab7c7b126594edd22cde
    timestamp:2019-11-06 20:36:52
    transaction:陈春林支付100元给CFA2019。
    hash:000006fab56318bd5dbbbba3e02a4664376ba005fa77e61badb0424bd5a792eb
    nonce:51068
    use time:190.7510757446289ms
    ----------
    index:2
    previous_hash:000006fab56318bd5dbbbba3e02a4664376ba005fa77e61badb0424bd5a792eb
    timestamp:2019-11-06 20:36:53
    transaction:道富集团捐赠10000元给CFA2019。
    hash:000000654034fd53b27e1a1886a46280f101415ef84aaf860ff7c5616d7fe126
    nonce:27157448
    use time:117276.28588676453ms
    ----------



---

如果有两个电脑几乎同时算出来，都有了记账权，都发布了新的区块（不同的节点收到两个区块的先后顺序不同），谁的是合法的呢？（网络速度原因、地域差别等等），**暂时都认为合法，暂时保留，分支**，等待下一个区块，看下一个区块接到哪一个分支上？（如果又出现同样的事情呢？）

---

4. 临时分叉的规则

小额交易： 3个区块就可以
大额交易： 6个区块，大约1小时(但不能多于2小时）

实际上： 小额交易往往花的时间更长，可能1-2天？ 为什么？

#### 思考或讨论：

为什么？ 小额交易的手续费更贵，而大额交易反而更便宜呢？经济学解释？

---
一个区块的空间是有限的，之前是1MB，大约是4000条，稀缺资源如何利用？

小额收费贵，防止恶意阻塞

---

### 4. 如何防止双花（同一个比特币被重复使用）？

如何防止同一个比特币被重复使用？

#### 什么是双花问题

在数字化货币系统中，由于数据的可复制性，使得系统可能存在同一笔数字资产因不当操作被重复使用的情况，这也称之为双花。

> 假如有个人A，只有一个比特币，却“同时”把自己的这个比特币支付给用户B和C（理论上无法真正的同时，但可以理解为间隔时间极短），这样，在网络上几乎同时有两条交易信息在广播，一条是A支付给B的信息，一条是A支付给C的信息。由于网络的种种原因，总会有一些电脑先收到信息是A支付给B，有的电脑是先收到A支付给C。

这就产生了矛盾。到底哪一条信息是有效的呢？


![blockchain-double-spending.png](attachment:blockchain-double-spending.png)

现实生活中，我们所说的双花包括两种纬度，一种从交易的维度，一种从货币本身的维度。货币的维度，比如，伪造货币；交易的维度，比如利用时间差，重复支付等。

在比特币中，
货币的维度来看，由于加密的技术，伪造货币几乎不可能。（我们知道在区块链上账户就是一个二维码的哈希地址，数字货币本身是不加密，加密的是账户，每个账户都具有成对的公私钥，每个账户进行货币转移时都需要用自己的私钥对交易进行数字签名，全网通过公钥对交易进行所有权验证，区块链从密码学的角度解决了货币本身所有权的问题；）

那从交易的角度来看呢？

两笔交易信息全网广播，所有的所有的区块链节点会收到广播的请求，同时每个节点上会存在全网所有的区块信息也就是全网的账户信息，来验证A交易的合法性。

两笔交易一前一后到达那肯定没啥好说的，全网任意一个节点都能验证出第二笔为重复支付；

若两笔交易同时达到两个节点中，两个节点同时验证为成功的同时广播到全网，若整个全网一部分阶段收到的是A支付给B，一部分节点收到的是A支付给C都对本地数据进行了更新，那全网就出现了分叉。

好在区块链对交易的确认有两点：1. 存在与最长分支中的block，2. 至少有5个验证过的block再其后面得到验证。所以出现分叉之后，全网的矿工会继续按照自己的区块更新，再之后的几次区块中自然会更新出最长的一条区块来，全网的所有矿工都以最长的区块信息为准。

如果A想要保持两笔交易都被确认，那他需要对全网所有的节点进行对抗，保持在两个分叉链上同时更新，显然是没法做到的。

![blockchain-the-longest-chain-wins.png](attachment:blockchain-the-longest-chain-wins.png)

**区块链正是利用加密技术首先保证了货币维度的不可伪造性，同时，利用分叉规则，解决了交易维度的难以伪造，从而基本解决了“双花”的问题。**

**区块链解决了账户同步和信息不重复的问题，这就使去中心账本的理想最终得以实现。**

#### 思考：
1. 区块链技术的设计思想，这种思想利用了什么样的技术设计和规则设计？这些规则存在什么样的局限（问题）或者例外的场景？你认为可以如何改进？
2. 区块链技术解决的问题除了去中心化的应用，在中心化应用场景（我们日常生活中最多的应用场景）中也适用吗？
3. 你认为有哪些问题是不适宜区块链技术的？

## 参考资料


* [比特币白皮书英文](https://www.bitcoin.com/bitcoin.pdf)
* [比特币白皮书中文](https://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system)
* [How the Bitcoin protocol actually works](http://www.michaelnielsen.org/ddi/how-the-bitcoin-protocol-actually-works/)
* [awesome-blockchain-cn中文资料](https://github.com/henfee/awesome-blockchain-cn)
* [黑马程序员 120天全栈区块链开发 开源教程](https://github.com/itheima1/BlockChain)
* [比特币入门教程](http://www.ruanyifeng.com/blog/2018/01/bitcoin-tutorial.html)
* [区块链入门教程](http://www.ruanyifeng.com/blog/2017/12/blockchain-tutorial.html)
* [加密货币的本质](http://www.ruanyifeng.com/blog/2018/01/cryptocurrency-tutorial.html)
* [金融如何被科技影响和改变——以区块链技术为例](https://mp.weixin.qq.com/s/U9yual78CYH-VWeyv3oVsQ)

---


## 扩展练习：


*  [Dumbcoin - An educational python implementation of a bitcoin-like blockchain](https://github.com/julienr/ipynb_playground/blob/master/bitcoin/dumbcoin/dumbcoin.ipynb)
* [A Practical Introduction to Blockchain with Python 文章](http://adilmoujahid.com/posts/2018/03/intro-blockchain-bitcoin-python/)
  * [Blockchain Python tutorial代码](https://github.com/adilmoujahid/blockchain-python-tutorial)

* [blockchain 开源教程：从零开始写区块链](https://github.com/OpensourceBooks/blockchain)
*  [一个区块链原型程序](https://github.com/SWUFE-labs/blockchain/blob/master/blockchain.py)

